#### 向右滚的优化

如果多次回滚不成功，我们索性就直接把所有的日志都发过去（snapshot）。让Follower直接拷贝Leader的状态。这样也许可以节省一部分RPC请求。

#### 捎带提交

在一些Case中，测试程序会高速发送请求。如果我们为每一个请求都发送一个RPC call的话，在极端的网络环境下，会造成Raft协议状态的混乱。

我的作法是把所有的请求先缓存起来，等到Leader发送心跳的时候再把数据统一发出。

这是虽然是一个Nagle算法的拙劣模仿，但是你不给我提供TCP协议，自己硬造一个也不过分吧。

> 实践证明在本项目中优化的效果不大，甚至可能会有负作用

#### 及时发送心跳 & 减少锁争用 

几乎所有RPC都涉及Raft状态协议的变更，所以加锁也会比较频繁。频繁进行锁争用的结果是一些必须的RPC请求无法发出，引发选举超时，从而造成雪崩效应。

所以我们尽可能优先发送心跳，保证Leader任期的延续。

> 这个貌似挺重要的

#### Bonus Track: Chaos挑战！

Raft的论文里面有提到过，Raft算法可以并发的表决多个提案。在我的实现中，除了捎带提交，或者“向右滚”的情况之外，都是每次表决一个提案。

所以这里有一个不成熟的优化，就是在Raft算法中实现一个滑动窗口，在接收到当前Term，但并不连续的提案时，允许Log当中留有空隙，然后通过ACK/NACK的方式要求Leader重新发送Log。

这种优化对于Leader比较稳定，同时并发写入压力比较大的场景效果比较好。但是由于测试用例中并没有这种情况，所以只做为一个Bonus挑战。

如果你真是闲的没事，可以玩一下。
